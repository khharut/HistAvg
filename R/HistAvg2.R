
#' Dynamic threshold calculator
#'
#' Finds dynamic threshold for data in JSON format
#' @author Harutyun Khachatryan, Tigran Khachikyan, Anoush Ghambaryan
#' @param json.str JSON input can be both string or file path
#' @param figure.out logical TRUE/FALSE indicating if after analysis a plot of analysis will be created
#' @param legacy.plot logical TRUE/FALSE indicating if plot will be new style i.e. last three days with thresholds
#' or old one i.e. 2 plots: 1) raw data plot and 2) all raw data points, last day line and thresholds
#' (default value is FALSE)
#' @param dmin fixed step (minutes) between two neighbours in derived dynamic threshold. Default value is 10, but
#' in case when it is impossible to calculate with that step, then it autocorrected
#' @param out.path plot output file folder path, should be accessible for write. Default value is " ", in that
#' case plot file will be generated in working directory of R and plot file path anyway is written in output information
#' generated by this method
#' @param sens shows confidence interval has three values "low", "medium" and "high" (default is "low")
#' @param test.mode logical TRUE/FALSE showing if test mode is enabled or not, default is FALSE
#' @return JSON string containing
#' a) field "data" containing [timestamp, lower, upper]... upper and lower thresholds along with timestamps
#' b) field "quality" containing estimated threshold quality value from 0 to 100
#' c) field "periodicty" containing periodicty reliability
#' d) field "image" containing full path of created image when figure.out input paramater is TRUE
#' e) field "errMsg" containing error messages of any error occured during calculation
#' f) field "warnMsg" containing warning messages of any non-critical error occured during calculation
#' @export
#' @importFrom RJSONIO fromJSON
#' @importFrom rjson toJSON
#' @importFrom pracma Mode trapz
#' @importFrom gmp as.bigz
#' @importFrom grid viewport
#' @importFrom ggplot2 ggplot geom_line geom_vline geom_ribbon geom_point aes
#' @importFrom ggplot2 theme_bw theme aes_string element_line element_text
#' @importFrom ggplot2 element_blank ggtitle
#' @importFrom stats approx ar coefficients cor.test median diffinv na.omit
#' @importFrom stats predict qf sd quantile stl time ts var
#' @importFrom grDevices dev.off png
#' @examples library("HistAvg2")
#' data(periodic)
#' jsondata<- RJSONIO::toJSON(periodic)
#' HistAvg2(jsondata)
HistAvg2 <- function(json.str, figure.out = FALSE, legacy.plot = FALSE, dmin = NA, out.path = " ", sens = "low", test.mode = FALSE)
{
  if ((sens != "low") & (sens != "medium") & (sens != "high") )
  {
    sens <- "low"
  }
  th.reliab <- 0
  thresh_type <- "None"
  per.reliab <- 0
  status <- FALSE
  dermes <- FALSE
  trend <- FALSE
  per7d <- FALSE
  statio <- FALSE
  peri <- FALSE
  hinto <- FALSE
  trendy <- FALSE
  hard_thresh <- 0
  xstat <- 0
  pquant <- 0.01
  cquant <- 1 - 2 * pquant
  stationary <- TRUE
  daynum <- 0
  dt.minute <- 0
  pred.reliab <- 0
  varx <- 0
  ##initialization####################################################
  Sys.setenv(TZ = 'GMT')
  s <- fromJSON(json.str, nullValue = NA)
  errmes <- ""
  warnmes <- ""
  havg2filenames <- ""
  xt <- mat.or.vec(0, 0)
  x <- mat.or.vec(0, 0)
  mon_id <- NA
  if (length(s) > 0)
  {
    if ( (length(names(s)) > 0) & (length(names(s[[1]])) > 0) )
    {
      mon_id <- names(s)
      s <- s[[1]]
    }
  }
  xt <- append(as.numeric(names(s)), xt)
  x <- append(as.vector(s), x)
  if ( (mode(x) == "list") & (length(xt) == 0) & (length(s) > 0) )
  {
    xt <- unlist(x)[seq(1, length(unlist(x)), by = 2)]
    x <- unlist(x)[seq(2, length(unlist(x)), by = 2)]
  }
  if (length(x) == 0)
  {
    rm(x)
    x <- c(0)
    if (!dermes)
    {
      errmes <- paste(errmes, "Unknown input data type.", sep = "", collapse = NULL)
    }
    dermes <- TRUE
  }
  if (length(xt) == 0)
  {
    xt[1] <- 0
    if (!dermes)
    {
      errmes <- paste(errmes, "Unknown input data type.", sep = "", collapse = NULL)
    }
    dermes <- TRUE
  }
  if (length(which(is.na(x))))
  {
    x <- x[-which(is.na(x))]
    xt <- xt[-which(is.na(x))]
  }
  if (length(which(is.na(xt))))
  {
    x <- x[-which(is.na(xt))]
    xt <- xt[-which(is.na(xt))]
  }
  if (is.unsorted(xt, na.rm = TRUE, strictly = TRUE))
  {
    sindi <- order(xt)
    xt <- xt[sindi]
    x <- x[sindi]
  }
  if (length(xt) > 2)
  {
    dtime0 <- median(diff(xt))
    dtime <- as.numeric(Mode(diff(xt)))
    varx <- var(x, na.rm = TRUE)
  } else
  {
    dtime <- 0
    dtime0 <- 0
  }
  if ( (dtime0 > 0) & (dtime > 0) )
  {
    alpha <- dtime / dtime0
  } else
  {
    alpha <- 1
  }
  if (dtime < 60000)
  {
    dtime <- 60000 * ceiling(dtime / 60000)
  }
  dt.minute <- dtime / 60000
  ##intervals-number of days, obs-number of observation per day#####
  ##nobs-number of observation in time series#######################
  if (dtime > 0)
  {
    intervals <- trunc( (xt[length(xt)] - xt[1]) / (1000 * 60 * 60 * 24) ) + 1
    nobs <- trunc( (intervals * 60 * 60 * 24 * 1000) / dtime)
  } else
  {
    nobs <- 0
    intervals <- 1
  }
  if (length(nobs) == 0)
  {
    nobs <- 0
  }
  obs <- ceiling(nobs / intervals)
  if ( (nobs >= 4 * length(xt)) | (length(xt) < 3) | (intervals <= 1) | (dtime >= (6 * 60 * 60 * 1000)) | (alpha < 0.5) | (varx == 0) )
  {
    if ( (alpha >= 0.5) & (!dermes) & (length(xt) < 3) )
    {
      errmes <- paste(errmes, "Not enough data. At least 3 data point should be supplied.", sep = "", collapse = NULL)
      dermes <- TRUE
    }
    if ( (alpha >= 0.5) & (!dermes) & (intervals <= 1) )
    {
      errmes <- paste(errmes, "Not enough data. At least 2 days of data should be supplied.", sep = "", collapse = NULL)
      dermes <- TRUE
    }
    if ( (alpha >= 0.5) & (!dermes) & (nobs >= 4 * length(xt)) )
    {
      errmes <- paste(errmes, "Not enough data. At least 25% of data points should be supplied.", sep = "", collapse = NULL)
      dermes <- TRUE
    }
    if ( (alpha >= 0.5) & (!dermes) & (dtime >= (6 * 60 * 60 * 1000)) )
    {
      errmes <- paste(errmes, "Time steps between timestamps should be less than 6 hours.", sep = "", collapse = NULL)
      dermes <- TRUE
    }
    if ( (varx == 0) & (!dermes) )
    {
      errmes <- paste(errmes, "Impossible to calculate thresholds for constant data.", sep = "", collapse = NULL)
      dermes <- TRUE
    }
    if ( (alpha < 0.5) & (!dermes) )
    {
      errmes <- paste(errmes, "Time step between timestamps are not fixed.", sep = "", collapse = NULL)
      dermes <- TRUE
    }
  }
  if (!dermes)
  {
    sec_of_day <- 24 * 60 * 60
    daynum <- intervals
    if (all(x >= 0))
    {
      positive <- TRUE
    } else
    {
      positive <- FALSE
    }
    p.value <- 0.31
    r.value <- 2
    if (r.value > max(x, na.rm = TRUE))
    {
      r.value <- max(x, na.rm = TRUE)
    }
    first.time <- trunc(as.POSIXct(xt[1] / 1000, origin = "1970-01-01", tz = "GMT"), "day")
    last.time <- trunc(as.POSIXct(xt[length(xt)] / 1000, origin = "1970-01-01", tz = "GMT"),"day")
    start.time <- as.POSIXct(xt[1] / 1000, origin = "1970-01-01", tz = "GMT")
    end.time <- as.POSIXct(xt[length(xt)] / 1000, origin = "1970-01-01",tz = "GMT")
    if (!is.na(dmin))
    {
      if ( (dmin <= 0) | (dmin > (12 * 60)) | (dmin < (2 * dt.minute)) )
      {
        dmin <- 2 * dt.minute
        warnmes <- paste(warnmes, "Unexpected value of threshold time step. It has been corrected.", sep = "", collapse = NULL)
      }
    } else
    {
      dmin <- 2 * dt.minute
    }
    dates <- as.POSIXct(xt / 1000, origin = "1970-01-01",tz = "GMT")
    datesn <- seq(from = start.time, to = end.time, by = paste(as.character(dtime / 1000), "secs", sep = " ", collapse = NULL))
    xnorm <- approx( x = xt / 1000, y = x, xout = as.numeric(datesn), method = "constant", f = 0, rule = 2)$y
    if (intervals > 3)
    {
      x.trend <- as.vector(stl(ts(xnorm, frequency = obs), s.window = "per", robust = TRUE)$time.series[ ,"trend"])
    } else
    {
      x.trend <- rep(0,length(xnorm))
    }
    hint <- HurstWrapper2(xnorm)
    rhoval <- ARIMAWrapper2(xnorm)
    if (hint > 0.9)
    {
      hinto <- TRUE
    }
    nstep <- length(datesn)
    apeak7d1 <- NRel2(xnorm, 7 * obs)
    apeak7d2 <- NRel2(x.trend, 7 * obs)
    apeak <- NRel2(xnorm, obs)
    ksvals <- KSValues2(xnorm, obs)
    ksdata <- KSInfo2(ksvals)
    if (ksdata$type < 3)
    {
      ksvals0 <- KSValues2((xnorm - x.trend), obs)
      ksdata0 <- KSInfo2(ksvals0)
      if (ksdata$type >= ksdata0$type)
      {
        rm("ksdata0")
        rm("ksvals0")
      } else
      {
        ksdata$weekchange <- ksdata0$weekchange
        ksdata$type <- ksdata0$type
        ksdata$weekly7 <- ksdata0$weekly7
        ksdata$weekly52 <- ksdata0$weekly52
        rm("ksdata0")
        rm("ksvals0")
        if ((apeak7d2[2] == 0) & (STest2(x.trend) > 0) & (hinto))
        {
          trendy <- TRUE
          warnmes <- paste(warnmes, "Trend in data is detected.", sep = "", collapse = NULL)
        }
      }
    }
    prob_num <- ksdata$nchange
    apeak7d <- c(7 * obs, max(c(apeak7d1[2], apeak7d2[2])))
    if ((apeak7d1[2] > 0.8) & (apeak7d2[2] > 0.8)  & (!hinto))
    {
      statio <- TRUE
      per7d <- TRUE
    }
    if ((apeak7d1[2] > 0.7) & (apeak7d2[2] > 0.7)  & (apeak[2] > 0.7) & (!hinto))
    {
      statio <- TRUE
    }
    if ((apeak7d1[2] > 0.8) & (apeak[2] < p.value) & (!hinto))
    {
      statio <- TRUE
      per7d <- TRUE
    }
    if ((apeak7d1[2] > 0.6) & (apeak[2] < p.value) & ((apeak[2] > p.value) | (apeak7d2[2] > p.value)) & (!hinto))
    {
      per7d <- TRUE
    }
    if ((apeak7d2[2] > 0.6) & (apeak[2] < p.value) & ((apeak[2] > p.value) | (apeak7d1[2] > p.value)) & (!hinto))
    {
      per7d <- TRUE
    }
    if ((apeak7d1[2] > 0.5) & (apeak7d2[2] > 0.5) & (ksdata$type > 0))
    {
      per7d <- TRUE
    }
    if ((apeak7d1[2] > 0.9) & (apeak7d2[2] > p.value) & (!hinto))
    {
      statio <- TRUE
      per7d <- TRUE
    }
    if ((apeak7d1[2] > 0.6) & (apeak[2] > p.value) & (ksdata$type >= 2))
    {
      per7d <- TRUE
    }
    if ((apeak7d2[2] > 0.9) & (!hinto))
    {
      if (apeak[2] > 0)
      {
        statio <- TRUE
        } else
        {
          peri <- TRUE
        }
      if (apeak7d1[2] > 0)
      {
        per7d <- TRUE
      }
    }
    if ((apeak[2] > 0.8) & (!hinto))
    {
      peri <- TRUE
    }
    if ((apeak[2] > 0.9) & (!hinto))
    {
      statio <- TRUE
    }
    if ((apeak7d1[2] > 0.75) & (apeak7d2[2] > 0.75))
    {
      per7d <- TRUE
    }
    if ((apeak7d1[2] < apeak[2]) & ((0.5 * (apeak7d1[2] + apeak7d2[2])) < apeak[2]))
    {
      per7d <- FALSE
    }
    if ((rhoval > 0.92) & (hint >= 0.82))
    {
      statio <- FALSE
    }
    if (ksdata$highly_unstable)
    {
      statio <- FALSE
    }
    if ((!statio) & (apeak7d[2] > 0.6))
    {
      peri <- TRUE
    }
    if ((!statio) & (apeak[2] > 0.6))
    {
      peri <- TRUE
    }
    if (prob_num == 0)
    {
      statio <- TRUE
    }
    if (apeak7d[2] > 0)
    {
      if (((apeak7d1[2] * apeak7d2[2]) > 0) & (ksdata$type > 1))
      {
        per7d <- TRUE
      }
      if ((min(c(apeak[2], apeak7d[2]), na.rm = TRUE) > 0.6) & (!per7d))
      {
        per7d <- (ksdata$weekly52 | ksdata$weekly7)
      }
      if ((apeak7d1[2] > p.value) & (apeak7d2[2] > 0.7) & (!per7d) & (ksdata$type > 0))
      {
        per7d <- TRUE
      }
      if ((apeak7d2[2] > p.value) & (apeak7d1[2] > 0.7) & (!per7d) & (ksdata$type > 0))
      {
        per7d <- TRUE
      }
      if ((apeak7d[2] > 0.6) & (apeak[2] > 0.7) & (!per7d) & (ksdata$type > 0))
      {
        per7d <- TRUE
      }
      if ((apeak[2] > p.value) & (apeak7d1[2] > 0.7) & (!per7d) & (ksdata$type > 0))
      {
        per7d <- TRUE
      }
      if ((apeak7d[2] > p.value) & (apeak[2] > 0.5) & (!per7d) & (ksdata$type > 0))
      {
        per7d <- TRUE
      }
    }
    if ((!statio) & (prob_num > 0))
    {
      allchindex <- suppressWarnings(StatLen2(xnorm, obs, hinto, peri, prob_num))
    }
    else
    {
      allchindex <- list(strong = c(1, nstep), weak = c(1, nstep))
    }
    chindex <- allchindex$strong
    tchindex <- allchindex$weak
    tchindex <- tchindex[-c(1, length(tchindex))]
    chindex0 <- chindex[-c(1, length(chindex))]
    tchindex <- setdiff(tchindex, chindex0)
    if (length(which(chindex0 >= (nstep - obs))) > 2)
    {
      chindex0 <- c(chindex0[which(chindex0 < (nstep - obs))], range(chindex0[which(chindex0 >= (nstep - obs))]))
    }
    if (per7d)
    {
      if ( (length(chindex0) > 0) & (length(ksdata$weekchange) > 0) )
      {
        kweekpattern <- sapply(chindex0, function(w) min(abs(ksdata$weekchange - w), na.rm = TRUE))
        kch7ind <- which(kweekpattern <  (0.75 * obs))
        if (length(kch7ind) > 0)
        {
          chindex0 <- chindex0[-kch7ind]
        }
        if ( (length(chindex0) >= 2) & (!trendy) )
        {
          weekpattern0 <- sapply(chindex0, function(w) {temp <- abs(w - chindex0); temp[temp < obs] <- NA; return(temp)})
          weekpattern0 <- weekpattern0 / obs
          weekpattern0 <- (weekpattern0 - 3.5) %% 7 + 3.5
          diag(weekpattern0) <- -1
          ch7ind0 <- unlist(apply(weekpattern0, 1, function(w) which( (w > 6.98) & (w < 7.02) )))
          ch7ind0 <- sort(unique(ch7ind0))
          if (length(ch7ind0) > 0)
          {
            chindex0 <- chindex0[-ch7ind0]
          } else
          {
            per7d <- FALSE
          }
        }
      }
    }
    if ( ((apeak7d[2] > 0.72) & (!ksdata$highly_unstable)) | ((per7d) & (ksdata$type == 0)) )
    {
      if ( (length(chindex0) > 1) & (length(ksdata$weekchange) == 0) )
      {
        weekpattern <- sapply(chindex0, function(w) {temp <- abs(w - chindex0); temp[temp < obs] <- NA; return(temp)})
        weekpattern <- weekpattern / obs
        weekpattern <- (weekpattern - 3.5) %% 7 + 3.5
        diag(weekpattern) <- -1
        ch7ind <- unlist(apply(weekpattern, 1, function(w) which( (w > 6.95) & (w < 7.05) )))
        ch7ind <- sort(unique(ch7ind))
        if (length(ch7ind) > 0)
        {
          per7d <- TRUE
          chindex0 <- chindex0[-ch7ind]
        }
      }
    }
    ##################################################################
    if (length(chindex0) > 0)
    {
      if ((as.numeric(last.time) - as.numeric(datesn[chindex0[length(chindex0)]])) < sec_of_day)
      {
        last_chindex <- chindex0[((as.numeric(last.time) - as.numeric(datesn[chindex0])) < sec_of_day)]
        lstest <- LDTest2(dates, datesn[last_chindex], obs)
        if (length(last_chindex) > 1)
        {
          deltax <- as.numeric(max(datesn[last_chindex], na.rm = TRUE)) - as.numeric(min(datesn[last_chindex], na.rm = TRUE))
        } else
        {
          deltax <- 12 * dtime / 1000
        }
        if ((lstest > 0) & (deltax > (12 * dtime / 1000)))
        {
          chindex0 <- setdiff(chindex0, last_chindex)
        }
      }
    }
    ##################################################################
    bad_data <- BadInd2(xnorm, datesn, dates, chindex0, hinto)
    if (length(bad_data$indices) > 0)
    {
      x <- x[-bad_data$indices]
      xt <- xt[-bad_data$indices]
      dates <- dates[-bad_data$indices]
      temp_chindex <- setdiff(chindex0, bad_data$stat)
      tchindex <- setdiff(tchindex, temp_chindex)
      chindex0 <- bad_data$stat
      if (max(dates, na.rm = TRUE) < max(datesn, na.rm = TRUE))
      {
        datesn <- datesn[-which(datesn > max(dates, na.rm = TRUE))]
        last.time <- trunc(as.POSIXct(xt[length(xt)] / 1000, origin = "1970-01-01", tz = "GMT"),"day")
        end.time <- as.POSIXct(xt[length(xt)] / 1000, origin = "1970-01-01",tz = "GMT")
      }
      if (min(dates, na.rm = TRUE) > min(datesn, na.rm = TRUE))
      {
        datesn <- datesn[-which(datesn < min(dates, na.rm = TRUE))]
        first.time <- trunc(as.POSIXct(xt[1] / 1000, origin = "1970-01-01", tz = "GMT"), "day")
        start.time <- as.POSIXct(xt[1] / 1000, origin = "1970-01-01", tz = "GMT")
      }
      xnorm <- approx(x = xt / 1000, y = x, xout = as.numeric(datesn), method = "constant", f = 0, rule = 2)$y
      nstep <- length(datesn)
      if (length(chindex0) > 0)
      {
        chindex0 <- chindex0[which((datesn[chindex0] <= max(dates, na.rm = TRUE)) & (datesn[chindex0] >= min(dates, na.rm = TRUE)))]
      }
    }
    ##################################################################
    if (length(chindex0) > 0)
    {
      stationary <- FALSE
    }
    ##################################################################
    if (any(ksvals[, 2] > 3))
    {
      if (per7d)
      {
        if ( (length(tchindex) > 0) & (any(tchindex < (nstep - 14 * obs))) )
        {
          chindex10 <- max(tchindex[which(tchindex < (nstep - 14 * obs))], na.rm = TRUE)
        } else
        {
          chindex10 <- tchindex[-seq(1, length(tchindex))]
        }
      } else
      {
        if ( (length(tchindex) > 0) & (any(tchindex < (nstep - 7 * obs))) )
        {
          chindex10 <- max(tchindex[which(tchindex < (nstep - 7 * obs))], na.rm = TRUE)
        } else
        {
          chindex10 <- tchindex[-seq(1, length(tchindex))]
        }
      }
    } else
    {
      chindex10 <- tchindex[-seq(1, length(tchindex))]
    }
    ##################################################################
    if (length(chindex0) > 0)
    {
      chindex <- chindex0[length(chindex0)]
    } else
    {
      chindex <- 1
    }
    chtime <- datesn[chindex]
    chtime0 <- datesn[chindex0[-length(chindex0)]]
    ##################################################################
    if (any(ksvals[, 2] > 3))
    {
      if ( (nstep > (14 * obs)) & (chindex == 1) & (length(chindex10) > 0) & (per7d))
      {
        chindex <- chindex10
        chtime <- datesn[chindex]
      }
      if ( (nstep > (7 * obs)) & (chindex == 1) & (length(chindex10) > 0) & (!per7d))
      {
        chindex <- chindex10
        chtime <- datesn[chindex]
      }
    }
    ##################################################################
    if (chindex > 1)
    {
      xnorm <- xnorm[min(c(chindex + 1, (nstep - 1)), na.rm = TRUE):nstep]
      ksvals[, 1] <- ksvals[, 1] - chindex
      ksvals <- ksvals[ksvals[, 1] >= obs, ]
      ksdata <- KSInfo2(ksvals)
      apeak <- NRel2(xnorm, obs)
      datesn <- datesn[min(c(chindex + 1, (nstep - 1)), na.rm = TRUE):nstep]
      nstep <- length(datesn)
      daynum <- nstep / obs
      if (daynum < 14)
      {
        per7d <- FALSE
      }
      hint <- HurstWrapper2(xnorm)
      if (hint > 0.9)
      {
        hinto <- TRUE
      } else
      {
        hinto <- FALSE
      }
      rchindex <- max(which(dates < chtime), na.rm = TRUE)
    } else
    {
      rchindex <- 0
      nstep <- length(datesn)
      daynum <- nstep / obs
      if (length(bad_data$indices) > 0)
      {
        apeak <- NRel2(xnorm, obs)
      }
    }
    ##################################################################
    if ((hinto) | (ksdata$highly_unstable))
    {
      xstat <- suppressWarnings(STest2(xnorm))
      if ((daynum > 3) & (xstat > 0))
      {
        xnorm <- xnorm[(nstep - (3 * obs)):nstep]
        datesn <- datesn[(nstep - (3 * obs)):nstep]
        daynum <- 3
      }
    }
    if ((ksdata$highly_unstable) & (xstat == 0) & (suppressWarnings(STest2(xnorm[(nstep - obs):nstep])) > 0))
    {
      xnorm <- xnorm[(nstep - obs):nstep]
      datesn <- datesn[(nstep - obs):nstep]
      daynum <- 1
    }
    if ((ksdata$highly_unstable) & (xstat == 0) & (suppressWarnings(STest2(xnorm[(nstep - obs):nstep])) == 0))
    {
      apeak[2] <- 0.8
    }
    ##################################################################
    ymax <- max(x, na.rm = TRUE)
    ymin <- min(x, na.rm = TRUE)
    rhoval <- ARIMAWrapper2(xnorm)
    if ( (per7d) & (apeak7d[2] > apeak[2]) )
    {
      apeak[2] <- apeak7d[2]
    }
    ##################################################################
    ndates <- seq(from = last.time + (dmin * 30),to = last.time + 24 * 60 * 60, by = paste(as.character(dmin * 30),"secs", sep = " ", collapse = NULL))
    if (ndates[length(ndates)] == (last.time + 24 * 60 * 60)) {ndates <- ndates[-length(ndates)]}
    ##################################################################
    per.reliab <- round(100 * apeak[2], 3)
    ##################################################################
    xlen <- (length(x) - rchindex)
    mindelta <- abs(diff(x))
    if (any(mindelta > 0))
    {
      mindelta <- min(mindelta[mindelta > 0])
    } else
    {
      mindelta <- r.value
    }
    x.quan <- as.vector(quantile(x[(rchindex + 1):length(x)], probs = c(pquant, (1 - pquant), (7 * obs - 1) / (7 * obs), (obs - 1) / obs), na.rm = TRUE))
    hard_thresh <- x.quan[c(3, 4)]
    if ((apeak[2] >= 0.2) & (apeak[2] <= 0.5) & (daynum >= 3) & any(xnorm > hard_thresh[2]))
    {
      day_spikes <- which(xnorm > hard_thresh[2])
      dday_spikes <- diff(day_spikes) - 1
      ddday_spikes <- abs((dday_spikes - 0.5 * obs) %% obs - 0.5 * obs)
      if (all(ddday_spikes <= 5) & all(dday_spikes < 3 * obs) & any(dday_spikes > (0.95 * obs)) & (day_spikes[length(day_spikes)] >= (nstep - obs)))
      {
        apeak[2] <- sum(ddday_spikes == 0) / length(day_spikes)
        per.reliab <- round(100 * apeak[2], 3)
      }
    } else
    {
      if ((apeak7d[2] > 0.1) & (!per7d) & (daynum >= 21) & any(xnorm > hard_thresh[1]))
      {
        week_spikes <- which(xnorm > hard_thresh[1])
        dweek_spikes <- diff(week_spikes) - 1
        ddweek_spikes <- abs((dweek_spikes - 3.5 * obs) %% (7 * obs) - 3.5 * obs)
        if (all(ddweek_spikes <= 3) & all(dweek_spikes < 15 * obs) & any(dweek_spikes > (6.95 * obs)) & (week_spikes[length(week_spikes)] >= (nstep - 7 * obs)))
        {
          per7d <- TRUE
          if ((apeak[2] < apeak7d[2]) & (apeak7d[2] >= 0.5))
          {
            apeak[2] <- apeak7d[2]
            per.reliab <- round(100 * apeak[2], 3)
          }
        }
      }
    }
    x.quan <- x.quan[c(1, 2)]
    x.med <- median(x[(rchindex + 1):length(x)], na.rm = TRUE)
    varx <- var(x[(rchindex + 1):length(x)], na.rm = TRUE)
    x.mean <- mean(x[(rchindex + 1):length(x)], na.rm = TRUE)
    if ( (rhoval > 0.9) & (hinto) )
    {
      x.quan <- sort(x.quan)
      x.dquan <- 0.5 * abs(diff(x.quan))
      if ( (x.med > ymin) & (x.med < ymax) )
      {
        x.quan[1] <- max(c(x.quan[1], x.med - x.dquan), na.rm = TRUE)
        x.quan[2] <- min(c(x.quan[2], x.med + x.dquan), na.rm = TRUE)
      }
    }
    if (x.quan[1] == x.quan[2])
    {
      x.quan[1] <- x.quan[1] - 0.5 * r.value
      x.quan[2] <- x.quan[2] + 0.5 * r.value
    }
    ##################################################################
    if ( (xstat == 0) & (xlen > 300) & (daynum > 1))
    {
      x.groups <- DivGroups2(xt, x, delta_min = dmin, ch_ind = rchindex, overlap = TRUE, loop = TRUE)
      if (any(is.na(x.groups)))
      {
        x.groups[is.na(x.groups)] <- x.mean
      }
      if (daynum >= 2)
      {
        if (daynum >= 7)
        {
          npout <- 2 * HRound(dmin / dt.minute)
          x.limits <- CalcOnGroups2(x.groups,
                func_calc = function(w) HistQuantile2(w, hprobs = c(pquant, (1 - pquant)), limits = x.quan, nout = npout),
                    func_def = function(w) mean(w, na.rm = TRUE))
          x.down <- sapply(1:length(x.groups), function(w) x.groups[[w]][which(x.groups[[w]] < x.limits[[w]][[1]])] - x.limits[[w]][[1]])
          x.up <- sapply(1:length(x.groups), function(w) x.groups[[w]][which(x.groups[[w]] > x.limits[[w]][[2]])] - x.limits[[w]][[2]])
          x.mix <- c(unlist(x.down), unlist(x.up))
          x.fqstore <- StepY2(x.mix, sens)
        } else
        {
          data.predicter <- Predicter2(xnorm, datesn, is_positive = positive, trend_only = FALSE, psense = sens)
          pred.reliab <- data.predicter$reliability
          pdates <- 1000 * as.numeric(data.predicter$thresholds[ ,1])
          pdates <- rep(pdates, 2)
          prediction <- c(data.predicter$thresholds[ ,2], data.predicter$thresholds[ ,3])
          x.pgroups <- DivGroups2(pdates, prediction, delta_min = dmin, ch_ind = NA, overlap = TRUE, loop = TRUE)
          if (any(is.na(x.pgroups))) {x.pgroups[which(is.na(x.groups))] <- x.mean}
          x.limits <- CalcOnGroups2(x.pgroups,
                                   func_calc = function(w) range(w, na.rm = TRUE),
                                   func_def = function(w) median(w, na.rm = TRUE))
        }
        x.range <- CalcOnGroups2(x.groups,
                func_calc = function(w) range(w, na.rm = TRUE),
                func_def = function(w) median(w, na.rm = TRUE))
        x.qup <- as.vector(sapply(x.limits, function(w) unname(w[[2]])))
        x.qdown <- as.vector(sapply(x.limits, function(w) unname(w[[1]])))
        x.qmax <- as.vector(sapply(x.range, function(w) unname(w[[2]])))
        x.qmin <- as.vector(sapply(x.range, function(w) unname(w[[1]])))
        ndates <- as.numeric(names(x.limits))
        ndates <- as.POSIXct(ndates/1000, tz = "GMT", origin = "1970-01-01")
        x.fqup <- x.qup
        x.fqdown <- x.qdown
        if (daynum >= 7)
        {
          x.qup <- x.qup + abs(x.fqstore[2])
          x.qdown <- x.qdown - abs(x.fqstore[1])
        }
        if ((any(abs(x.qup - x.qdown) < mindelta)) & (mindelta > 0))
        {
          ind_eq <- which(abs(x.qup - x.qdown) < mindelta)
          x.qup[ind_eq] <- x.qup[ind_eq] + (0.5 * mindelta)
          x.qdown[ind_eq] <- x.qdown[ind_eq] - (0.5 * mindelta)
        }
        if (varx > 0)
        {
          if (any( (x.qup > ymax) | (!is.finite(x.qup)) )) {x.qup[which( (x.qup > ymax) | (!is.finite(x.qup)) )] <- ymax}
          if (any( (x.qdown < ymin) | (!is.finite(x.qdown)) )) {x.qdown[which( (x.qdown < ymin) | (!is.finite(x.qdown)) )] <- ymin}
          if (any( (x.fqup > ymax) | (!is.finite(x.fqup)) )) {x.fqup[which( (x.fqup > ymax) | (!is.finite(x.fqup)) )] <- ymax}
          if (any( (x.fqdown < ymin) | (!is.finite(x.fqdown)))) {x.fqdown[which((x.fqdown < ymin) | (!is.finite(x.fqdown)))] <- ymin}
        }
      } else {ndates <- c(last.time, ndates, last.time + 24 * 60 * 60)}
      ##################################################################
      x.cqup <- rep(x.quan[2], length(ndates))
      x.cqdown <- rep(x.quan[1], length(ndates))
      x.climits <- list()
      lnames <- as.character(as.bigz(1000 * as.numeric(ndates)))
      length(x.climits) <- length(ndates)
      names(x.climits) <- lnames
      x.climits <- lapply(x.climits, function(w) x.quan)
      x.cdown <- sapply(1:length(x.groups), function(w) x.groups[[w]][which(x.groups[[w]] < x.climits[[w]][[1]])] - x.climits[[w]][[1]])
      x.cup <- sapply(1:length(x.groups), function(w) x.groups[[w]][which(x.groups[[w]] > x.climits[[w]][[2]])] - x.climits[[w]][[2]])
      x.cmix <- c(unlist(x.cdown), unlist(x.cup))
      x.fcqstore <- StepY2(x.cmix, sens)
      x.fcqup <- x.cqup
      x.fcqdown <- x.cqdown
      x.cqup <- x.cqup + abs(x.fcqstore[2])
      x.cqdown <- x.cqdown - abs(x.fcqstore[1])
      if ((x.cqup[1] == x.cqdown[1]) & (mindelta > 0))
      {
        x.cqup <- x.cqup + (0.5 * mindelta)
        x.cqdown <- x.cqdown - (0.5 * mindelta)
      }
      if (varx > 0)
      {
        if (length(which(x.cqup > ymax)) > 0) {x.cqup[which(x.cqup > ymax)] <- ymax}
        if (length(which(x.cqdown < ymin)) > 0) {x.cqdown[which(x.cqdown < ymin)] <- ymin}
      }
      ##################################################################
      if (daynum >= 2)
      {
        dth1 <- x.qmax - x.qup
        dth1[dth1 < 0] <- 0
        dth2 <- x.qdown - x.qmin
        dth2[dth2 < 0] <- 0
        s0 <- (trapz(as.numeric(ndates), x.qmax) - trapz(as.numeric(ndates), x.qmin))
        if ( (is.na(s0)) | (is.infinite(s0)) )
        {
          s0 <- 0
        }
        if (s0 == 0)
        {
          s0 <- trapz(as.numeric(ndates), rep(r.value, length(ndates)))
        }
        if (daynum >= 7)
        {
          dthresh.reliab <- (trapz(as.numeric(ndates), dth1) + trapz(as.numeric(ndates), dth2)) / s0
          thresh.reliab <- 1.0 - dthresh.reliab
        } else
        {
          thresh.reliab <- pred.reliab
        }
        ##################################################################
        cdth1 <- x.qmax - x.cqup
        cdth1[cdth1 < 0] <- 0
        cdth2 <- x.cqdown - x.qmin
        cdth2[cdth2 < 0] <- 0
        cdth3 <- x.qmax - x.cqup
        cdth3[cdth3 > 0] <- 0
        cdth4 <- x.cqdown - x.qmin
        cdth4[cdth4 > 0] <- 0
        cthresh.reliab <- cquant * (1 - (trapz(as.numeric(ndates), (cdth1 + cdth2)) / s0))
        cthreshin.reliab <- (trapz(as.numeric(ndates), abs(cdth3)) + trapz(as.numeric(ndates), abs(cdth4))) / s0
        ##################################################################
        if (daynum >= 7)
        {
          if ((cthreshin.reliab < dthresh.reliab) & (apeak[2] >= 0.2) & (apeak[2] < 0.75))
          {
            thresh.reliab <- thresh.reliab / cthresh.reliab
            x.qup <- x.cqup
            x.qdown <- x.cqdown
            x.fqup <- x.fcqup
            x.fqdown <- x.fcqdown
            thresh_type <- "constant"
          }
          if ((cthreshin.reliab >= dthresh.reliab) & (apeak[2] >= 0.2) & (apeak[2] < 0.75))
          {
            th.reliab <- thresh.reliab
            thresh_type <- "periodic"
          }
          if (apeak[2] >= 0.75)
          {
            th.reliab <- thresh.reliab
            thresh_type <- "periodic"
          }
          if ( (apeak[2] < 0.2) & (cthresh.reliab <= thresh.reliab) )
          {
            th.reliab <- cthresh.reliab
            x.qup <- x.cqup
            x.qdown <- x.cqdown
            x.fqup <- x.fcqup
            x.fqdown <- x.fcqdown
            thresh_type <- "constant"
          }
          if ( (apeak[2] < 0.2) & (cthresh.reliab > thresh.reliab) )
          {
            th.reliab <- thresh.reliab / cthresh.reliab
            x.qup <- x.cqup
            x.qdown <- x.cqdown
            x.fqup <- x.fcqup
            x.fqdown <- x.fcqdown
            thresh_type <- "constant"
          }
        } else
        {
          if ((thresh.reliab > 0.70) & (apeak[2] > p.value))
          {
            th.reliab <- thresh.reliab
            warnmes <- paste(warnmes,"Last stable period is too short. Prediction based automatic thresholds is used.", sep = "", collapse = NULL)
            thresh_type <- "prediction"
          } else
          {
            th.reliab <- cthresh.reliab
            x.qup <- x.cqup
            x.qdown <- x.cqdown
            x.fqup <- x.fcqup
            x.fqdown <- x.fcqdown
            thresh_type <- "constant"
          }
        }
        ##################################################################
        th.reliab <- round(100 * th.reliab, 3)
      } else
      {
        x.qup <- x.cqup
        x.qdown <- x.cqdown
        x.fqup <- x.fcqup
        x.fqdown <- x.fcqdown
        if (max(xnorm, na.rm = TRUE) != min(xnorm, na.rm = TRUE))
        {
          th.reliab <- round(98 * (x.cqup[1] - x.cqdown[1]) / (max(xnorm, na.rm = TRUE) - min(xnorm, na.rm = TRUE)), 3)
        } else
        {
          th.reliab <- 98
        }
        thresh_type <- "constant"
      }
      ##################################################################
      status <- TRUE
    }
    ##################################################################
    if ( (!status) & (daynum > 1) & (xstat == 0) & (xlen > 10) )
    {
      ndates <- c(last.time,ndates,last.time + 24 * 60 * 60)
      x.qup <- rep(x.quan[2], length(ndates))
      x.qdown <- rep(x.quan[1], length(ndates))
      x.limits <- list()
      lnames <- as.character(as.bigz(1000 * as.numeric(ndates)))
      length(x.limits) <- length(ndates)
      names(x.limits) <- lnames
      x.limits <- lapply(x.limits, function(w) x.quan)
      if (max(xnorm, na.rm = TRUE) != min(xnorm, na.rm = TRUE))
      {
        th.reliab <- min(c(round(98 * (x.qup[1] - x.qdown[1]) / (max(xnorm, na.rm = TRUE) - min(xnorm, na.rm = TRUE)), 3), 98))
      } else
      {
        th.reliab <- 98
      }
      thresh_type <- "constant"
      status <- TRUE
    }
    ##################################################################
    ##################################################################
    if ( (!status) & (daynum >= 1) & (xstat > 0) )
    {
      trend.predicter <- Predicter2(xnorm, datesn, is_positive = positive, trend_only = TRUE, psense = sens)
      pred.reliab <- trend.predicter$reliability
      tpdates <- 1000 * as.numeric(trend.predicter$thresholds[ ,1])
      tpdates <- rep(tpdates, 2)
      tprediction <- c(trend.predicter$thresholds[ ,2], trend.predicter$thresholds[ ,3])
      x.tpgroups <- DivGroups2(tpdates, tprediction, delta_min = dmin, ch_ind = NA, overlap = TRUE, loop = FALSE)
      x.limits <- CalcOnGroups2(x.tpgroups,
                               func_calc = function(w) range(w, na.rm = TRUE),
                               func_def = function(w) median(w, na.rm = TRUE))
      x.qup <- as.vector(sapply(x.limits, function(w) unname(w[[2]])))
      x.qdown <- as.vector(sapply(x.limits, function(w) unname(w[[1]])))
      ndates <- as.numeric(names(x.limits))
      ndates <- as.POSIXct(ndates/1000, tz = "GMT", origin = "1970-01-01")
      th.reliab <- 100 * round(pred.reliab, 3)
      thresh_type <- "trend prediction"
      status <- TRUE
      trend <- TRUE
    }
    if (th.reliab > 100)
    {
      th.reliab <- 98
    }
    ##################################################################
    if (figure.out)
    {
      pwidth <- 1024
      pheight <- 768
      if ( (is.numeric(out.path)) | (out.path == "") | (out.path == " ") )
      {
        out.path <- getwd()
      }
      realfile <- json.str
      if (nchar(realfile) > 100)
      {
        realfile <- substr(json.str, nchar(json.str) - 10, nchar(json.str))
      }
      if (is.na(mon_id))
      {
        havg2.filename <- paste(as.character(round(1000000000 * as.numeric(Sys.time()))), ".png", sep = "")
        havg2.filename <- paste("havg2", havg2.filename, sep = "")
      } else
      {
        havg2.filename <- paste(as.character(mon_id), ".png", sep = "")
      }
      daylines <- as.numeric(seq(first.time, by = paste(as.character(24 * 60 * 60), "secs", sep = " ", collapse = NULL), length = intervals + 3))
      havg2.filename <- file.path(out.path, havg2.filename)
      png(filename = havg2.filename, width = pwidth, height = pheight)
      if (legacy.plot)
      {
        qdates <- last.time + OneDayProj2(xt, rchindex) / 1000
        vpdown <- viewport(width = 1, height = 0.5,just = "top")
        vpup <- viewport(width = 1, height = 0.5,just = "bottom")
        if (is.na(mon_id))
        {
          real_title <- paste("Raw unnormalized data. File=", realfile, sep = "")
        } else
        {
          real_title <- paste("Raw unnormalized data. Monitor_id=", as.character(mon_id), sep = "")
        }
        real_data <- data.frame(Time = dates, Value = x)
        plt_real <- ggplot() + geom_line(aes(x = Time, y = Value), data = real_data, colour =  "#7F25D9")
        plt_real <- plt_real + theme_bw()
        plt_real <- plt_real + theme(panel.grid.major = element_line(colour = 1, linetype = 2), panel.grid.minor = element_blank(), text = element_text(size = 14))
        if (chindex > 1)
        {
          if (length(chtime0) > 0)
          {
            tmpchtime <- as.numeric(chtime0)
            for (i in 1:length(tmpchtime))
            {
              plt_real <- plt_real + geom_vline(aes_string(xintercept = tmpchtime[i]), colour = "black")
            }
          }
          if (length(chtime) > 0) {plt_real <- plt_real + geom_vline(aes_string(xintercept = as.numeric(chtime)), colour = "red")}
        }
        plt_real <- plt_real + geom_vline(aes_string(xintercept = daylines), colour = "gray", linetype = 3)
        plt_real <- plt_real + ggtitle(real_title)
        print(plt_real, vp = vpup)
        ##################################################################
        if (status)
        {
          analyse_title <- "Dynamic thresholds."
          analyse_title <- paste(analyse_title, " Quality ", sep = "")
          analyse_title <- paste(analyse_title, as.character(th.reliab), sep = "")
          analyse_title <- paste(analyse_title, "%", sep = "")
          analyse_title <- paste(analyse_title, ", Periodicity ", sep = "")
          analyse_title <- paste(analyse_title, as.character(per.reliab), sep = "")
          analyse_title <- paste(analyse_title, "%", sep = "")
          analyse_title <- paste(analyse_title, ", Step ", sep = "")
          analyse_title <- paste(analyse_title, as.character(round(dmin, 3)), sep = "")
          analyse_title <- paste(analyse_title, " min.", sep = "")
          mon_data <- data.frame(Time = qdates, Value = x[(rchindex + 1):length(x)])
          qtdata <- data.frame(Time = ndates, Upper = x.qup, Lower = x.qdown)
          plt_analyse <- ggplot() + geom_ribbon(aes(x = Time, ymin = Lower, ymax = Upper), data = qtdata, fill = "#C8E281")
          plt_analyse <- plt_analyse + geom_point(aes(x = Time, y = Value), data = mon_data, size = 0.5, colour = "#D33939")
          plt_analyse <- plt_analyse + theme_bw()
          plt_analyse <- plt_analyse + theme(panel.grid.major = element_line(colour = 1, linetype = 3),
                                                     panel.grid.minor = element_blank(), text = element_text(size = 14))
          if (any(ndates <= chtime))
          {
            plt_analyse <- plt_analyse + geom_vline(aes_string(xintercept = as.numeric(chtime)), colour = "black")
          }
          plt_analyse <- plt_analyse + ggtitle(analyse_title)
          print(plt_analyse, vp = vpdown)
        } else
        {
          fstep_data <- data.frame(Time = datesn, Value = xnorm)
          plt_fstep <- ggplot() + geom_line(aes(x = Time, y = Value), data = fstep_data, colour =  "#7F25D9")
          plt_fstep <- plt_fstep + theme_bw()
          plt_fstep <- plt_fstep + theme(panel.grid.major = element_line(colour = 1, linetype = 2),
                                                 panel.grid.minor = element_blank(), text = element_text(size = 14))
          fstep_title <- "Last stable period."
          plt_fstep <- plt_fstep + ggtitle(fstep_title)
          print(plt_fstep, vp = vpdown)
        }
      } else
      {
        if (status)
        {
          real_data <- data.frame(Time = dates, Value = x)
          qtdata1 <- data.frame(Time = ndates, Upper = x.qup, Lower = x.qdown)
          qtdata2 <- qtdata1
          qtdata3 <- qtdata1
          qtdata4 <- qtdata1
          qtdata1$Time <- qtdata4$Time - 3 * 24 * 60 * 60
          qtdata2$Time <- qtdata4$Time - 2 * 24 * 60 * 60
          qtdata3$Time <- qtdata4$Time - 1 * 24 * 60 * 60
          qtdata <- rbind(qtdata1, qtdata2, qtdata3, qtdata4)
          rm(qtdata1)
          rm(qtdata2)
          rm(qtdata3)
          rm(qtdata4)
          real_days <- (as.numeric(real_data$Time[length(real_data$Time)]) - as.numeric(real_data$Time[1])) / (24 * 60 * 60)
          if (real_days > 3)
          {
            real_data <- real_data[(real_data[,1] > (real_data$Time[length(real_data$Time)] - 3 * 24 * 60 * 60)), ]
          }
          if ( (max(qtdata$Time, na.rm = TRUE) - dmin * 60) > max(real_data$Time, na.rm = TRUE))
          {
            qtdata <- qtdata[((qtdata$Time - dmin * 60) <= max(real_data$Time, na.rm = TRUE)), ]
          }
          if ((min(qtdata$Time, na.rm = TRUE) + 60 * dmin) < min(real_data$Time, na.rm = TRUE))
          {
            qtdata <- qtdata[((qtdata$Time + 60 * dmin) >= min(real_data$Time, na.rm = TRUE)), ]
          }

          if ( max(daylines, na.rm = TRUE) > max(real_data$Time, na.rm = TRUE))
          {
            daylines <- daylines[daylines <= max(real_data$Time, na.rm = TRUE)]
          }
          if ( min(daylines, na.rm = TRUE) < min(real_data$Time, na.rm = TRUE))
          {
            daylines <- daylines[daylines >= min(real_data$Time, na.rm = TRUE)]
          }

          if (is.na(mon_id))
          {
            title3d <- paste("Last 3 days with thresholds. File=", realfile, sep = "")
          } else
          {
            title3d <- paste("Last 3 days with thresholds. Monitor_id=", as.character(mon_id), sep = "")
          }
          title3d <- paste(title3d, "\n", sep = "")
          title3d <- paste(title3d, " Quality ", sep = "")
          title3d <- paste(title3d, as.character(th.reliab), sep = "")
          title3d <- paste(title3d, "%", sep = "")
          title3d <- paste(title3d, ", Periodicity ", sep = "")
          title3d <- paste(title3d, as.character(per.reliab), sep = "")
          title3d <- paste(title3d, "%", sep = "")
          title3d <- paste(title3d, ", Step ", sep = "")
          title3d <- paste(title3d, as.character(dmin), sep = "")
          title3d <- paste(title3d, " min.", sep = "")
          plt_3day <- ggplot() + geom_ribbon(aes(x = Time, ymin = Lower, ymax = Upper), data = qtdata, fill = "#C8E281")
          plt_3day <- plt_3day + geom_line(aes(x = Time, y = Value), data = real_data, colour =  "#D33939", size = 1)
          plt_3day <- plt_3day + theme_bw()
          plt_3day <- plt_3day + theme(panel.grid.major = element_line(colour = 1, linetype = 2),
                                               panel.grid.minor = element_blank(), text = element_text(size = 14))
          plt_3day <- plt_3day + geom_vline(aes_string(xintercept = daylines), colour = "gray", linetype = 3)
          plt_3day <- plt_3day + ggtitle(title3d)
          print(plt_3day)
        } else
        {
          real_data <- data.frame(Time = datesn, Value = xnorm)
          real_days <- (as.numeric(real_data$Time[length(real_data$Time)]) - as.numeric(real_data$Time[1])) / (24 * 60 * 60)
          if (real_days > 3)
          {
            real_data <- real_data[(real_data[,1] > (real_data$Time[length(real_data$Time)] - 3 * 24 * 60 * 60)), ]
          }
          if ( max(daylines, na.rm = TRUE) > max(real_data$Time, na.rm = TRUE))
          {
            daylines <- daylines[daylines <= max(real_data$Time, na.rm = TRUE)]
          }
          if ( min(daylines, na.rm = TRUE) < min(real_data$Time, na.rm = TRUE))
          {
            daylines <- daylines[daylines >= min(real_data$Time, na.rm = TRUE)]
          }
          if (is.na(mon_id))
          {
            title3d <- paste("Last 3 days. File=", realfile, sep = "")
          } else
          {
            title3d <- paste("Last 3 days. Monitor_id=", as.character(mon_id), sep = "")
          }
          plt_3day <- ggplot() + geom_line(aes(x = Time, y = Value), data = real_data, colour =  "#7F25D9", size = 1)
          plt_3day <- plt_3day + theme_bw()
          plt_3day <- plt_3day + theme(panel.grid.major = element_line(colour = 1, linetype = 2),
                                               panel.grid.minor = element_blank(), text = element_text(size = 14))
          plt_3day <- plt_3day + geom_vline(aes(xintercept = as.numeric(daylines)), colour = "gray", linetype = 3)
          plt_3day <- plt_3day + ggtitle(title3d)
          print(plt_3day)
        }
      }
      ##################################################################
      dev.off()
      havg2filenames <- havg2.filename
    }
    ##################################################################
    if (!status)
    {
      if (xstat >= 0)
      {
        errmes <- paste(errmes, "Impossible to calculate automatic thresholds. At least 2 days of stable data should be supplied.", sep = "", collapse = NULL)
      }
      if (xstat < 0)
      {
        errmes <- paste(errmes, "Impossible to calculate automatic thresholds. Data is highly unstable.", sep = "", collapse = NULL)
      }
    }
  }
  if ((per7d) & (thresh_type != "constant"))
  {
    warnmes <- paste(warnmes, "Seven days periodicity is detected.", sep = "", collapse = NULL)
  }
  if ((per7d) & (thresh_type == "constant"))
  {
    warnmes <- paste(warnmes, "Seven days spiky feature is detected.", sep = "", collapse = NULL)
  }
  if (status)
  {
    if (xstat != 0)
    {
      warnmes <- paste(warnmes, "Input data is highly unstable. Trend prediction threshold is used.", sep = "", collapse = NULL)
    }
    hthresh <- cbind(as.list(as.character(as.bigz(1000 * as.numeric(ndates)))), as.list(round(x.qup, 4)), as.list(round(x.qdown, 4)))
    hthresh <- apply(hthresh, 1 , as.list)
  } else
  {
    hthresh <- list()
  }
  if (!test.mode)
  {
    outjson.str <- toJSON(list(data = hthresh, quality = th.reliab, periodicity = per.reliab, status = as.numeric(status),
                                   image = havg2filenames, errMsg = errmes, warnMsg = warnmes))
  } else
  {
    outjson.str <- toJSON(list(quality = th.reliab, periodicity = per.reliab, status = as.numeric(status), per7d = per7d, ndays = round(daynum, 3), stationary = stationary, time_delta = dt.minute,
                                   thresh_type = thresh_type, image = havg2filenames, errMsg = errmes, warnMsg = warnmes))
  }
  return(outjson.str)
}

#' Dynamic threshold calculator, test purposes
#'
#' Finds dynamic threshold for data in JSON format,
#' HistAvg2 wrapped in try to work without any error on MapReduce or Spark framework
#' This method works in any case and if something goes wrong writes output JSON
#' format string explaining problem
#' @author Harutyun Khachatryan, Tigran Khachikyan, Anoush Ghambaryan
#' @param json.str JSON input can be both string or file path
#' @param figure.out logical TRUE/FALSE indicating if after analysis a plot of analysis will be created
#' @param legacy.plot logical TRUE/FALSE indicating if plot will be new style i.e. last three days with thresholds
#' or old one i.e. 2 plots: 1) raw data plot and 2) all raw data points, last day line and thresholds
#' (default value is FALSE)
#' @param dmin fixed step (minutes) between two neighbours in derived dynamic threshold. Default value is 10, but
#' in case when it is impossible to calculate with that step, then it autocorrected
#' @param out.path plot output file folder path, should be accessible for write. Default value is " ", in that
#' case plot file will be generated in working directory of R and plot file path anyway is written in output information
#' generated by this method
#' @param sens shows confidence interval has three values "low", "medium" and "high" (default is "low")
#' @param test.mode logical TRUE/FALSE showing if test mode is enabled or not, default is FALSE
#' @export
HistAvg2.test <- function(json.str, figure.out = FALSE, legacy.plot = FALSE, dmin = 10, out.path = " ", sens = "low", test.mode = FALSE)
{
  errmes <- try(hisavg <- HistAvg2(json.str = json.str, figure.out = figure.out, legacy.plot = legacy.plot, dmin = dmin, out.path = out.path, sens = sens, test.mode = test.mode), silent = TRUE)
  if (exists("hisavg"))
  {
    return(hisavg)
  } else
  {
    if (test.mode)
    {
      outjson.str.havg2 <- "\"quality\":0,\"periodicity\":0,\"status\":0,\"per7d\":false,\"ndays\":0,\"stationary\":true,\"time_delta\":0,\"thresh_type\":\"None\""
      errmes <- paste("\"",gsub("\"","",as.character(errmes)), sep = "", collapse = NULL)
      errmes <- paste(errmes,"\"", sep = "", collapse = NULL)
      errmes <- paste("\"errMsg\":",errmes, sep = "", collapse = NULL)
      errmes <- gsub("\n","", errmes)
      files.outjson.str <- "\"image\":\"\""
      warnmes <- "\"warnMsg\":\"\""
      outjson.str <- paste(outjson.str.havg2,files.outjson.str, sep = ",", collapse = NULL)
      outjson.str <- paste(outjson.str,errmes, sep = ",", collapse = NULL)
      outjson.str <- paste(outjson.str,warnmes, sep = ",", collapse = NULL)
      outjson.str <- paste(outjson.str,"}", sep = "", collapse = NULL)
      outjson.str <- paste("{",outjson.str, sep = "", collapse = NULL)
      return(outjson.str)
    } else
    {
      outjson.str.havg2 <- "\"data\":[],\"quality\":0,\"periodicity\":0,\"status\":0"
      errmes <- paste("\"",gsub("\"","",as.character(errmes)), sep = "", collapse = NULL)
      errmes <- paste(errmes,"\"", sep = "", collapse = NULL)
      errmes <- paste("\"errMsg\":",errmes, sep = "", collapse = NULL)
      errmes <- gsub("\n","", errmes)
      files.outjson.str <- "\"image\":\"\""
      warnmes <- "\"warnMsg\":\"\""
      outjson.str <- paste(outjson.str.havg2,files.outjson.str, sep = ",", collapse = NULL)
      outjson.str <- paste(outjson.str,errmes, sep = ",", collapse = NULL)
      outjson.str <- paste(outjson.str,warnmes, sep = ",", collapse = NULL)
      outjson.str <- paste(outjson.str,"}", sep = "", collapse = NULL)
      outjson.str <- paste("{",outjson.str, sep = "", collapse = NULL)
      return(outjson.str)
    }
  }
}

#' Dynamic threshold calculator, cross-validation
#'
#' Splits data into train and test sets.
#' Calculates dynamic threshold on train set.
#' Then checks how many points violate dynamic threshold
#' and estimates accuracy value of dynamic threshold whether
#' that violation meaningfull or not.
#' This method calls HistAvg.test method, more expalntations
#' find there.
#' @author Harutyun Khachatryan
#' @param json.str JSON input can be both string or file path
#' @param figure.out logical TRUE/FALSE indicating if after analysis a plot of analysis will be created
#' @param legacy.plot logical TRUE/FALSE indicating if plot will be new style i.e. last three days with thresholds
#' or old one i.e. 2 plots: 1) raw data plot and 2) all raw data points, last day line and thresholds
#' (default value is FALSE)
#' @param dmin fixed step (minutes) between two neighbours in derived dynamic threshold. Default value is 10, but
#' in case when it is impossible to calculate with that step, then it autocorrected
#' @param out.path plot output file folder path, should be accessible for write. Default value is " ", in that
#' case plot file will be generated in working directory of R and plot file path anyway is written in output information
#' generated by this method
#' @param sens shows confidence interval has three values "low", "medium" and "high" (default is "low")
#' @export
HistAvg2.cv <- function(json.str, figure.out = FALSE, legacy.plot = FALSE, dmin = 10, out.path = " ", sens = "low")
{
  if ((sens != "low") & (sens != "medium") & (sens != "high") )
  {
    sens <- "low"
  }
  acc_all <- NA
  acc_nup <- NA
  acc_ndown <- NA
  varx <- 0
  dermes <- FALSE
  ##initialization####################################################
  Sys.setenv(TZ = 'GMT')
  errmes <- ""
  errm0 <- try(s <- fromJSON(json.str, nullValue = NA), silent = TRUE)
  if (!exists("s"))
  {
    s <- list()
    errmes <- paste(errmes, errm0, sep = "", collapse = NULL)
    dermes
  }
  xt <- mat.or.vec(0, 0)
  x <- mat.or.vec(0, 0)
  mon_id <- NA
  if (length(s) > 0)
  {
    if ( (length(names(s)) > 0) & (length(names(s[[1]])) > 0) )
    {
      mon_id <- names(s)
      s <- s[[1]]
    }
  }
  xt <- append(as.numeric(names(s)), xt)
  x <- append(as.vector(s), x)
  if ( (mode(x) == "list") & (length(xt) == 0) & (length(s) > 0) )
  {
    xt <- unlist(x)[seq(1, length(unlist(x)), by = 2)]
    x <- unlist(x)[seq(2, length(unlist(x)), by = 2)]
  }
  if (length(x) == 0)
  {
    rm(x)
    x <- c(0)
    if (!dermes)
    {
      errmes <- paste(errmes, "Unknown input data type.", sep = "", collapse = NULL)
    }
    dermes <- TRUE
  }
  if (length(xt) == 0)
  {
    xt[1] <- 0
    if (!dermes)
    {
      errmes <- paste(errmes, "Unknown input data type.", sep = "", collapse = NULL)
    }
    dermes <- TRUE
  }
  if (length(which(is.na(x))))
  {
    x <- x[-which(is.na(x))]
    xt <- xt[-which(is.na(x))]
  }
  if (length(which(is.na(xt))))
  {
    x <- x[-which(is.na(xt))]
    xt <- xt[-which(is.na(xt))]
  }
  if (is.unsorted(xt, na.rm = TRUE, strictly = TRUE))
  {
    sindi <- order(xt)
    xt <- xt[sindi]
    x <- x[sindi]
  }
  if (length(xt) > 2)
  {
    dtime0 <- median(diff(xt))
    dtime <- as.numeric(Mode(diff(xt)))
    varx <- var(x, na.rm = TRUE)
  } else
  {
    dtime <- 0
    dtime0 <- 0
  }
  if ( (dtime0 > 0) & (dtime > 0) )
  {
    alpha <- dtime / dtime0
  } else
  {
    alpha <- 1
  }
  if (dtime < 60000)
  {
    dtime <- 60000 * ceiling(dtime / 60000)
  }
  ##intervals-number of days, obs-number of observation per day#####
  ##nobs-number of observation in time series#######################
  if (dtime > 0)
  {
    intervals <- trunc( (xt[length(xt)] - xt[1]) / (1000 * 60 * 60 * 24) ) + 1
    nobs <- trunc( (intervals * 60 * 60 * 24 * 1000) / dtime)
  } else
  {
    nobs <- 0
    intervals <- 1
  }
  if (length(nobs) == 0)
  {
    nobs <- 0
  }
  if ( (nobs >= 4 * length(xt)) | (length(xt) < 3) | (intervals <= 1) | (dtime >= (6 * 60 * 60 * 1000)) | (alpha < 0.5) | (varx == 0) )
  {
    if ( (alpha >= 0.5) & (!dermes) & (length(xt) < 3) )
    {
      errmes <- paste(errmes, "Not enough data. At least 3 data point should be supplied.", sep = "", collapse = NULL)
      dermes <- TRUE
    }
    if ( (alpha >= 0.5) & (!dermes) & (intervals <= 1) )
    {
      errmes <- paste(errmes, "Not enough data. At least 2 days of data should be supplied.", sep = "", collapse = NULL)
      dermes <- TRUE
    }
    if ( (alpha >= 0.5) & (!dermes) & (nobs >= 4 * length(xt)) )
    {
      errmes <- paste(errmes, "Not enough data. At least 25% of data points should be supplied.", sep = "", collapse = NULL)
      dermes <- TRUE
    }
    if ( (alpha >= 0.5) & (!dermes) & (dtime >= (6 * 60 * 60 * 1000)) )
    {
      errmes <- paste(errmes, "Time steps between timestamps should be less than 6 hours.", sep = "", collapse = NULL)
      dermes <- TRUE
    }
    if ( (varx == 0) & (!dermes) )
    {
      errmes <- paste(errmes, "Impossible to calculate thresholds for constant data.", sep = "", collapse = NULL)
      dermes <- TRUE
    }
    if ( (alpha < 0.5) & (!dermes) )
    {
      errmes <- paste(errmes, "Time step between timestamps are not fixed.", sep = "", collapse = NULL)
      dermes <- TRUE
    }
  }
  if (!dermes)
  {
    train_len <- round(0.8 * length(x))
    xt_train <- xt[1:train_len]
    xt_test <- xt[(train_len + 1):length(x)]
    x_train <- x[1:train_len]
    x_test <- x[(train_len + 1):length(x)]
    temp_train_list <- list()
    temp_train_list[as.character(as.bigz(xt_train))] <- x_train
    json_train <- toJSON(temp_train_list)
    train_histavg <- unlist(fromJSON(HistAvg2.test(json_train, figure.out = figure.out, legacy.plot = legacy.plot, dmin = dmin, out.path = out.path, sens = sens, test.mode = FALSE))$data)
    if (is.null(train_histavg)) {return(toJSON(list(acc_all, acc_nup + acc_ndown, errmes)))}
    histavg_xt <- as.numeric(train_histavg[seq(1, length(train_histavg), 3)])
    histavg_oxt <- OneDayProj2(histavg_xt)
    xt_otest <- OneDayProj2(xt_test)
    histavg_up <- as.numeric(train_histavg[seq(2, length(train_histavg), 3)])
    histavg_down <- as.numeric(train_histavg[seq(3, length(train_histavg), 3)])
    if (any(duplicated(histavg_oxt)))
    {
      histavg_up <- histavg_up[-which(duplicated(histavg_oxt))]
      histavg_down <- histavg_down[-which(duplicated(histavg_oxt))]
      histavg_oxt <- histavg_oxt[-which(duplicated(histavg_oxt))]
    }
    x_test_up <- pmax(approx(x = histavg_oxt, y = histavg_up, xout = xt_otest, method = "constant", f = 0, rule = 2)$y,
                      approx(x = histavg_oxt, y = histavg_up, xout = xt_otest, method = "constant", f = 1, rule = 2)$y)
    x_test_down <- pmin(approx(x = histavg_oxt, y = histavg_down, xout = xt_otest, method = "constant", f = 0, rule = 2)$y,
                        approx(x = histavg_oxt, y = histavg_down, xout = xt_otest, method = "constant", f = 1, rule = 2)$y)
    x_test_dup <- x_test - x_test_up
    x_test_ddown <- x_test_down - x_test
    x_test_ldup <- (x_test_dup > 0)
    x_test_lddown <- (x_test_ddown > 0)
    acc_down <- 0; acc_ndown <- 0
    acc_up <- 0; acc_nup <- 0
    if (sum(c(x_test_ldup, x_test_lddown)) > 0)
    {
      if (any(x_test_ldup))
      {
        up_palerts <- x_test_dup[which(x_test_ldup)]
        up_dxs <- diff(x_test)[which(x_test_ldup) - 1]
        if (length(x_test_ldup) > 1) {up_dinds <- diff(seq(1, length(x_test))[which(x_test_ldup)])}
        up_palerts <- ((2 * up_palerts) >= up_dxs)
        if (length(x_test_ldup) > 1) {up_palerts[-1] <- up_palerts[-1] + (up_dinds == 1)}
        up_palerts <- (up_palerts > 0)
        acc_up <- sum(up_palerts)
        acc_nup <- length(up_palerts)
      }
      if (any(x_test_lddown))
      {
        down_palerts <- x_test_ddown[which(x_test_lddown)]
        down_dxs <- -diff(x_test)[which(x_test_lddown) - 1]
        if (length(x_test_lddown) > 1) {down_dinds <- diff(seq(1, length(x_test))[which(x_test_lddown)])}
        down_palerts <- ((2 * down_palerts) >= down_dxs)
        if (length(x_test_lddown) > 1) {down_palerts[-1] <- down_palerts[-1] + (down_dinds == 1)}
        down_palerts <- (down_palerts > 0)
        acc_down <- sum(down_palerts)
        acc_ndown <- length(down_palerts)
      }
    }
    if ((acc_nup + acc_ndown) > 0) {acc_all <- (acc_up + acc_down) / (acc_nup + acc_ndown)} else {acc_all <- 1}
  }
  return(toJSON(list(acc_all, acc_nup + acc_ndown, errmes)))
}
